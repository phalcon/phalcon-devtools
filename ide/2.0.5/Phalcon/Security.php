<?php

namespace Phalcon;

use Phalcon\DiInterface;
use Phalcon\Security\Exception;
use Phalcon\Di\InjectionAwareInterface;
use Phalcon\Session\AdapterInterface as SessionInterface;


class Security implements InjectionAwareInterface
{

	const CRYPT_DEFAULT	   =	0;

	const CRYPT_STD_DES	   =	1;

	const CRYPT_EXT_DES	   =	2;

	const CRYPT_MD5		   =	3;

	const CRYPT_BLOWFISH       =	4;

	const CRYPT_BLOWFISH_X     =	5;

	const CRYPT_BLOWFISH_Y     =	6;

	const CRYPT_SHA256	   =	7;

	const CRYPT_SHA512	   =	8;



	protected $_dependencyInjector;

	protected $_workFactor = 8;

	public function setWorkFactor($value) {
		$this->_workFactor = $value;
	}

	public function getWorkFactor() {
		return $this->_workFactor;
	}

	protected $_numberBytes = 16;

	protected $_tokenKeySessionID = '$PHALCON/CSRF/KEY$';

	protected $_tokenValueSessionID = '$PHALCON/CSRF$';

	protected $_csrf;

	protected $_defaultHash;



	/**
	 * Sets the dependency injector
	 * 
	 * @param DiInterface $dependencyInjector
	 *
	 * @return void
	 */
	public function setDI(DiInterface $dependencyInjector) {}

	/**
	 * Returns the internal dependency injector
	 *
	 * @return DiInterface
	 */
	public function getDI() {}

	/**
	 * Sets a number of bytes to be generated by the openssl pseudo random generator
	 * 
	 * @param int $randomBytes
	 *
	 * @return void
	 */
	public function setRandomBytes($randomBytes) {}

	/**
	 * Returns a number of bytes to be generated by the openssl pseudo random generator
	 *
	 * @return string
	 */
	public function getRandomBytes() {}

	/**
	 * Generate a >22-length pseudo random string to be used as salt for passwords
	 * 
	 * @param int $numberBytes
	 *
	 * @return string
	 */
	public function getSaltBytes($numberBytes) {}

	/**
			 * Produce random bytes using openssl
			 * Filter alpha numeric characters
	 * 
	 * @param string $password
	 * @param int $workFactor
			 *
	 * @return string
	 */
	public function hash($password, $workFactor) {}

	/**
	 * Checks a plain text password and its hash version to check if the password matches
	 * 
	 * @param string $password
	 * @param string $passwordHash
	 * @param int $maxPassLength
	 *
	 * @return boolean
	 */
	public function checkHash($password, $passwordHash, $maxPassLength) {}

	/**
	 * Checks if a password hash is a valid bcrypt's hash
	 * 
	 * @param string $passwordHash
	 *
	 * @return boolean
	 */
	public function isLegacyHash($passwordHash) {}

	/**
	 * Generates a pseudo random token key to be used as input's name in a CSRF check
	 * 
	 * @param int $numberBytes
	 *
	 * @return string
	 */
	public function getTokenKey($numberBytes=null) {}

	/**
	 * Generates a pseudo random token value to be used as input's value in a CSRF check
	 * 
	 * @param int $numberBytes
	 *
	 * @return string
	 */
	public function getToken($numberBytes=null) {}

	/**
	 * Check if the CSRF token sent in the request is the same that the current in session
	 * 
	 * @param mixed $tokenKey
	 * @param mixed $tokenValue
	 * @param boolean $destroyIfValid
	 *
	 * @return boolean
	 */
	public function checkToken($tokenKey=null, $tokenValue=null, $destroyIfValid=true) {}

	/**
		 * If tokenKey does not exist in session return false
		 *
	 * @return string
	 */
	public function getSessionToken() {}

	/**
	 * Removes the value of the CSRF token and key from session
	 *
	 * @return void
	 */
	public function destroyToken() {}

	/**
	 * Computes a HMAC
	 * 
	 * @param string $data
	 * @param string $key
	 * @param string $algo
	 * @param boolean $raw
	 *
	 *
	 * @return mixed
	 */
	public function computeHmac($data, $key, $algo, $raw=false) {}

	/**
 	 * Sets the default hash
	 * 
	 * @param mixed $defaultHash
 	 *
	 * @return void
	 */
	public function setDefaultHash($defaultHash) {}

	/**
 	 * Sets the default hash
 	 *
	 * @return mixed
	 */
	public function getDefaultHash() {}

}
