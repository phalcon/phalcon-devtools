<?php 

namespace Phalcon {

	/**
	 * Phalcon\Security
	 *
	 * This component provides a set of functions to improve the security in Phalcon applications
	 *
	 *<code>
	 *	$login = $this->request->getPost('login');
	 *	$password = $this->request->getPost('password');
	 *
	 *	$user = Users::findFirstByLogin($login);
	 *	if ($user) {
	 *		if ($this->security->checkHash($password, $user->password)) {
	 *			//The password is valid
	 *		}
	 *	}
	 *</code>
	 */
	
	class Security implements \Phalcon\Di\InjectionAwareInterface {

		const CRYPT_DEFAULT = 0;

		const CRYPT_STD_DES = 1;

		const CRYPT_EXT_DES = 2;

		const CRYPT_MD5 = 3;

		const CRYPT_BLOWFISH = 4;

		const CRYPT_BLOWFISH_X = 5;

		const CRYPT_BLOWFISH_Y = 6;

		const CRYPT_SHA256 = 7;

		const CRYPT_SHA512 = 8;

		protected $_dependencyInjector;

		protected $_workFactor;

		protected $_numberBytes;

		protected $_tokenKeySessionID;

		protected $_tokenValueSessionID;

		protected $_csrf;

		protected $_defaultHash;

		public function setWorkFactor($workFactor){ }


		public function getWorkFactor(){ }


		/**
		 * Sets the dependency injector
		 */
		public function setDI(\Phalcon\DiInterface $dependencyInjector){ }


		/**
		 * Returns the internal dependency injector
		 */
		public function getDI(){ }


		/**
		 * Sets a number of bytes to be generated by the openssl pseudo random generator
		 */
		public function setRandomBytes($randomBytes){ }


		/**
		 * Returns a number of bytes to be generated by the openssl pseudo random generator
		 */
		public function getRandomBytes(){ }


		/**
		 * Generate a >22-length pseudo random string to be used as salt for passwords
		 */
		public function getSaltBytes($numberBytes=null){ }


		/**
		 * Creates a password hash using bcrypt with a pseudo random salt
		 */
		public function hash($password, $workFactor=null){ }


		/**
		 * Checks a plain text password and its hash version to check if the password matches
		 */
		public function checkHash($password, $passwordHash, $maxPassLength=null){ }


		/**
		 * Checks if a password hash is a valid bcrypt's hash
		 */
		public function isLegacyHash($passwordHash){ }


		/**
		 * Generates a pseudo random token key to be used as input's name in a CSRF check
		 */
		public function getTokenKey($numberBytes=null){ }


		/**
		 * Generates a pseudo random token value to be used as input's value in a CSRF check
		 */
		public function getToken($numberBytes=null){ }


		/**
		 * Check if the CSRF token sent in the request is the same that the current in session
		 */
		public function checkToken($tokenKey=null, $tokenValue=null, $destroyIfValid=null){ }


		/**
		 * Returns the value of the CSRF token in session
		 */
		public function getSessionToken(){ }


		/**
		 * Removes the value of the CSRF token and key from session
		 */
		public function destroyToken(){ }


		/**
		 * Computes a HMAC
		 *
		 * @param string data
		 * @param string key
		 * @param string algo
		 * @param boolean raw
		 */
		public function computeHmac($data, $key, $algo, $raw=null){ }


		/**
		 * Sets the default hash
		 */
		public function setDefaultHash($defaultHash){ }


		/**
		 * Sets the default hash
		 */
		public function getDefaultHash(){ }

	}
}
