<?php

/*
  +------------------------------------------------------------------------+
  | Phalcon Developer Tools                                                |
  +------------------------------------------------------------------------+
  | Copyright (c) 2011-2016 Phalcon Team (http://www.phalconphp.com)       |
  +------------------------------------------------------------------------+
  | This source file is subject to the New BSD License that is bundled     |
  | with this package in the file docs/LICENSE.txt.                        |
  |                                                                        |
  | If you did not receive a copy of the license and are unable to         |
  | obtain it through the world-wide-web, please send an email             |
  | to license@phalconphp.com so we can send you a copy immediately.       |
  +------------------------------------------------------------------------+
  | Authors: Ivan Zinovyev <vanyazin@gmail.com>                            |
  +------------------------------------------------------------------------+
*/

namespace Phalcon\Version;

/**
 * Class TimestampItem
 *
 * Allows to manipulate versions based on timestamp value
 *
 * @package Phalcon\Version
 */
class TimestampItem
{
    /**
     * @var string
     */
    protected $_version;

    /**
     * @var boolean
     */
    protected $_isFullVersion;

    /**
     * @var array
     */
    private $_parts = [];

    /**
     * @param string $version Version name
     * @param int $numberParts Not implemented
     */
    public function __construct($version)
    {
        $this->_parts = explode('_', $version, 2);
        $this->_isFullVersion = isset($this->_parts[1]);
    }

    /**
     * @return bool
     */
    public function isFullVersion()
    {
        return $this->_isFullVersion;
    }

    /**
     * @return string
     */
    public function getVersion()
    {
        return $this->_version; // TODO: Change the autogenerated stub
    }

    /**
     * @return string
     */
    public function getVersionNumber()
    {
        return $this->_parts[0];
    }

    /**
     * @return string|null
     */
    public function getVersionDescription()
    {
        return $this->isFullVersion() ? $this->_parts[1] : null;
    }

    /**
     * @param $versions TimestampItem[]
     *
     * @return array TimestampItem[]
     */
    public static function sortAsc($versions)
    {
        $sortData = array();
        foreach ($versions as $version) {
            $sortData[$version->getVersionNumber()] = $version;
        }
        ksort($sortData);

        return array_values($sortData);
    }

    /**
     * @param $versions TimestampItem[]
     *
     * @return TimestampItem
     */
    public static function sortDesc($versions)
    {
        $sortData = array();
        foreach ($versions as $version) {
            $sortData[$version->getVersionNumber()] = $version;
        }
        krsort($sortData);

        return array_values($sortData);
    }

    /**
     * @param $versions TimestampItem[]
     *
     * @return TimestampItem
     */
    public static function maximum($versions)
    {
        if (count($versions) == 0) {
            return null;
        }

        $versions = self::sortDesc($versions);

        return $versions[0];
    }

    /**
     * Allows to check whether a version is in a range between two values.
     *
     * @param  string $initialVersion
     * @param  string $finalVersion
     * @param  array $versions TimestampItem[]
     * @return TimestampItem[]
     */
    public static function between($initialVersion, $finalVersion, $versions)
    {
        $versions = self::sortAsc($versions);

        if (!is_object($initialVersion)) {
            $initialVersion = new self($initialVersion);
        }

        if (!is_object($finalVersion)) {
            $finalVersion = new self($finalVersion);
        }

        $betweenVersions = array();
        if ($initialVersion->getVersionNumber() == $finalVersion->getVersionNumber()) {
            return $betweenVersions; // nothing to do
        }

        if ($initialVersion->getVersionNumber() < $finalVersion->getVersionNumber()) {
            $versions = self::sortAsc($versions);
        } else {
            $versions = self::sortDesc($versions);
            list($initialVersion, $finalVersion) = array($finalVersion, $initialVersion);
        }

        foreach ($versions as $version) {
            /** @var Item $version */
            if (
                ($version->getVersionNumber() >= $initialVersion->getVersionNumber())
                && ($version->getVersionNumber() <= $finalVersion->getVersionNumber())
            ) {
                $betweenVersions[] = $version;
            }
        }

        return $betweenVersions ;
    }

    /**
     * @deprecated Left for backwards compatibility with an old Item class
     *
     * @return string
     */
    public function getStamp()
    {
        return $this->getVersionNumber();
    }

    /**
     * @param $number
     *
     * @deprecated Left for backwards compatibility with an old Item class
     *
     * @return string
     */
    public function addMinor($number)
    {
        return $this->getVersionNumber();
    }


    /**
     * @return string
     */
    public function __toString()
    {
        return $this->getVersion(); // TODO: Change the autogenerated stub
    }
}